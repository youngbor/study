Java 基础知识

1. Math类
	abs(): 返回参数的绝对值
	ceil(): 返回大于等于（>=）给定参数的最小整数，类型为双精度浮点型。
	floor(): 返回小于等于（<=）给定参数的最大整数。
	rint(): 返回与参数最接近的整数。返回类型为double
	round(): 表示四舍五入，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)=12,Math.round(-11.5)=-11。
	min(): 返回两个参数中的最小值
	max(): 返回两个参数中的最大值
	pow(): 返回第一个参数的第二个参数次方
	sqrt(): 求参数的算术平方根
	random(): 返回一个随机数

	参数			Math.floor		Math.round		Math.ceil
	1.4			1				1				2
	1.5			1				2				2
	1.6			1				2				2
	-1.4		-2				-1				-1
	-1.5		-2				-1				-1
	-1.6		-2				-2				-1

2. Cahracter类
	isLetter(): 是否是一个字母
	isDigit(): 是否是一个数字字符
	isWhitespace(): 是否是一个空白字符
	isUpperCase(): 是否是大写字母
	isLowerCase(): 是否是小写字母
	toUpperCase(): 指定字母的大写形式
	toLowerCase(): 指定字母的小写形式
	toString(): 返回字符的字符串形式，字符串的长度仅为1

3. 正则表达式
	\: 将下一字符标记为特殊字符、文本、反向引用或八进制转义符
	^: 匹配输入字符串开始的位置。 shift + 6
	$: 匹配输入字符串结尾的位置。
	*: 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配 "z"和"zoo"。* 等效于{0,}
	+: 一次或多次匹配前面的字符或子表达式。例如，zo* 匹配 "zo"和"zoo",但与"z"不匹配。* 等效于{1,}
	?: 零次或一次匹配前面的字符或子表达式。例如，"do(es)?" 匹配 "do" 或 "does" 中的do。? 等效于{0,1}

3. 数学运算符
	<<: 左移运算符，num << 1 相当于 num 乘以2，低位补0
		eg: 3 << 2
		3 --> 二进制数 0000 0000 0000 0000 0000 0000 0000 0011
			--> 0000 0000 0000 0000 0000 0000 0000 1100
				--> 十进制 12
			等价于 3 * 2^2
		在数字没有溢出的前提下，对于正数和负数，左移一位相当于乘以2的1次方，左移n位相当于乘以2的n次方
	>>: 右移运算符
		eg: 11 >> 2
		11 --> 二进制数 0000 0000 0000 0000 0000 0000 0000 1011
			--> 0000 0000 0000 0000 0000 0000 0000 0010
				--> 十进制 3
		右移一位相当于除以2，右移n位相当于除以2的n次方。（取商去余）
	>>>: 无符号右移，忽略符号位，空位都以0补齐
		按二进制形式把所有的数字向右移动对应位数，低位移除（舍弃），高位的空位补零。对于正数来说和带符号的右移相同，对于负数来说不通。其他结构和>>相似
	%: 模运算 取余
		简单的求余运算
	^: 位异或 第一个操作数的第n位与第二个操作数的第n位相反，那么结果的第n位为1，否则为0
		eg: 0^0=0, 1^0=1, 0^1=1, 1^1=0
	&: 与运算 第一个操作数的第n位与第二个操作数的第n位如果都是1，那么结果第n位也为1，否则为0
		eg: 0&0=0, 0&1=0, 1&0=0, 1&1=1
	|: 或运算 第一个操作数的第n位与第二个操作数的第n位只要有一个是1，那么结果第n位为1，否则为0
		eg: 0|0=0, 0|1=1, 1|0=1, 1|1=1
	~: 非运算	 操作数的第n位为1，那么结果的第n位为0，反之，也就是取反运算
		eg: ~1=0, ~0=1
	0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111

	1000 0100 0111 0001 0000 0111 1000 0000
	0000 0000 0000 0000 0000 0000 0000 1111

	0000 0000 0000 0000 1000 0100 0111 0001
	0000 0000 0000 0000 0000 0000 0000 1111
						1000 0100 0111 1110

	10000100011100010000011110000000

	0111 0111 0011 1000 1010 0001 0100 0000
	0000 0000 0000 0000 0000 0000 0000 1111
						1010 0001 0100 1111

	HashMap规定哈希表长度为2的k次方 
		2的k次方-1 转为二进制就是k个连续的1
	寻址 tab[i = (n-1)&hash]
		hash & (k个连续的1) 返回的就是hash的低k个位，该计算结果范围刚好就是0-2^k-1,即0到lenth-1
		也就是说，哈希表长度 length 为 2 的整次幂时， hash & (length - 1) 的计算结果跟 hash % length 一样，而且效率还更好

		2^1-1=1  00000001 
		2^2-1=3  00000011
		2^3-1=7  00000111
		2^4-1=15 00001111
		2^5-1=31 00011111
		2^6-1=63 00111111
	HashMap 计算hash:
		(h = key.hashCode()) ^ (h >>> 16)

	String.hashCode()算法
		h = 31 * h + val[i]
		选择系数的时候要选择尽量长(31 = 11111[2])的系数并且让乘法尽量不要溢出(如果选择大于11111的数，很容易溢出)的系数，因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。

		31 * i = (i << 5) -i 位移运算比一般运算要快很多



	

